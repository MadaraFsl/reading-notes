1.查找基本概念：
  查找：根据所给的关键字在特定列表中进行对比匹配然后返回该元素在这个列表中的位置。</br>
  分类:1>.比较式查找：基于线性表的查找 + 基于树的查找     记录的位置和关键字之间无直接关系,所以需要一系列对比，查找效率依赖比较次数。          
       2>.计算式查找：又称Hash查找。 关键字和存储位置建立关系,查找时依靠哈希函数计算元素存储位置。                                 
 
2.1基于线性表的查找。 

  顺序查找：基于监视哨 + 循环对比。 
  int SeqSerach(List lst, KeyType k) { 
    lst.r[0].key = k; 
    i = lst.length; 
    while(lst.r[i].key != k) { 
      i--; 
    } 
    return i; 
  } 
   
  
  折半查找:二分查找。 
  int BinSerach(list lst, KeyType k) { 
    low = 1; high = lst.length;  //设置区间 
    while(low <= high) { 
      mid = (low + high)/2; 
      if(lst.r[mid].key == key) { 
        return mid; 
      } else if(k < lst.r[mid].key) {  //关键字在左半部,右边界减少1 
        high = mid - 1; 
      } else { </br>
        low = mid + 1; 
      } 
    } 
    return 0; 
  } 
  
  分块查找:列表分成子表,构造索引表。块内无序,块间有序。 
  查找:块外用二分查找，块内用顺序查找。 

2.2基于树的查找。 
  二叉查找树的：将二叉排序树看作一个有序表，和折半查找类似，也是一个逐步缩小查找范围的过程。 
  递归算法: 
  BSTree SearchBST(BSTree 不是他， KeyType key) { 
    if(!bst) { 
      return null; 
    } else if(bst.key == key) { 
      return bst; 
    } else if(bst.key > key) {</br>
      return BSTreeBST(bst.leftChild, key); //关键字小于当前根结点左查 
    } else { 
      return BSTreeBST(bst.rightChild, key); 
    } 
    
    非递归查找： 
    BSTree SearchBST(BSTree 不是他， KeyType key) { 
      BSTree q = bst; 
      while(q) {//循环遍历 
        if(bst.key == key) { 
          return q; 
        } else if (bst.key > key) { 
          q = q.leftChild; 
        } else { 
          q = q.rightChild; 
        } 
      } 
      //循环结束还未找到  
      return null; 
    } 
  } 
   
   
3.计算式查找:哈希法。 
 
  哈希冲突：关键字值不同的元素映射到同一地址上，称为冲突。 
  哈希函数构造原则：1.函数本身便于计算。2.计算出来的地址分不均匀。 
   
  常用的构造哈希函数的方法。 
  1>.数字分析法：事先知道关键字集合,当关键字的位数比哈希表的地址码的位数多时,可以从关键字中选出分布均匀的若干位,构成哈希地址。 
  2>.平方取中法：无法分析关键字中哪几位分布比较均匀,先求出关键字的平方值,然后按需要取平方值得中间几位作为哈希地址。 
    原因：关键字平方后中间得几位和关键字中每一位都相关,所以不同的关键字会以较高概率产生不同的哈希地址。 
  3>.分段叠加法:按照哈希表地址位数将关键字分成位数相等的几部分,然后相加,舍弃最高进位后的结果就是关键字的哈希地址。 
    移位法：分割后的低位对其相加. 
    折叠法:奇正加偶倒加。后相加。 
  4>.除留余数法：关键字值与小于等于哈希表长的最大素数的取余运算。冲突较多时扩大较大的值。（重点） 
  5>.伪随机数法：伪随机函数作为哈希函数。 
   
4.处理冲突:冲突不可完全避免,只能减少冲突。  
  解决冲突的方法: 
    1>.开放定址法:再散列法。以关键字构造的初始地址发生冲突,以这个初始地址再次构造地址,直到不再冲突.ThreadLocalMap的set()方法就采用的这个。
    hi = (h0 + di) % m  i = 1, 2, 3..., n   di:增量序列  m:表长  h为哈希函数。 
    增量序列的取值方式不同导致相应的再散列方式也不同: 
      <1>.线性探测再散列：发生冲突顺序查找表的下一个单元,直到找到空单元或查遍全表 
      <2>.二次探测再散列：仍然还是顺序,但是查找的变成从中间向两边同时查找,效率提高,比较灵活。 
      <3>.伪随机探测再散列:建立伪随机数发生器,给定随机数作为起点。 
      优:哈希表不满,线性探测一定可找到不冲突的哈希地址,但是其他两个不一定。但是其容易产生多次冲突。 
    2>.再哈希法：同时构造多个不同的哈希函数。  不易产生聚集,但是增加了计算时间。 
    3>.链地址法:单链表,每个结点又是一个动态数组。java中就是这样使用的。(重点)HashSet,桶排序。Map的put()方法。 
    4>.建立公共的溢出区:将哈希表分成基本表和溢出表,凡是发生冲突的元素一律填入溢出表。 
     
5.哈希表的性能: 
   影响因素:哈希函数     处理冲突方法    装填因子。 
   装填因子 = 哈希表中的元素的个数 / 哈希表的长度。  描述的式哈希表的装满程度。 
   java中HashSet装填因子为0.75.默认大小。过大过小都不适合。遵循一个叫做泊松分布的东东。 
   nodes in bins follows a Poisson distribution。 
