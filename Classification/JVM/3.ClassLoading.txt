1.虚拟机的类加载概述。
    类加载机制：虚拟机把用来描述类的数据从Class文件加载到内存，对数据进行校验、转换解析、初始化 ->java类型,可直接被虚拟机所使用。
    JAVA动态扩展的原因：运行期动态加载和动态连接。
    
2.类加载的时期：
    加载->连接->初始化->使用->卸载。
    连接包括:验证->连接->解析。
    除却解析和使用以外的步骤都是按部就班的进行。解析阶段则不一定:允许在某些情况下在初始化之后再开始。是为了支持运行时绑定。
    何时开始加载:1>.new出一个对象使用 + getset类的静态字段 + 调用静态方法时
                2>.对类进行反射的时候。这一点在框架中使用较多。
                3>.初始化类的时候父类还没初始化。
                4>入口地址的类即包含main函数的类,虚拟机需要找到一个可执行的主类。
                5>.动态代理的时候。
3.类加载的过程:加载->验证->准备->解析->初始化。
    加载:1>.通过全名来获取Class的二进制文件流。
         2>.将这个字节流代表的静态存储结构转换陈方法区的运行时数据结构。
         3>.内存中生成Class对象。作为数据的访问入口。
    验证:确保Class文件内部信息可靠且安全。
         1>.文件格式验证:验证字节流是否符合Class文件的规范,并且能否被当前虚拟机处理。
         2>.元数据验证:字节码信息的语义分析保证信息符合规范。数据类型的校验。
         3>.字节码验证:字节码信息的语义分析保证语义合法符合逻辑。类内部方法的验证。
         4>.符号引用验证:对类自身除外的各种符号引用进行匹配性的校验。如全名是否可以找到类,访问权限是否可以被当前类访问。
    准备:为类变量在方法区中分配内存并设置初始值。8大类型+引用类型的零/NULL值。
    解析:常量池中 符号引用->直接引用的替换过程。 
         符号引用：无歧义的可以定位到目标的一组符号。 引用目标不一定存在于内存中。
         直接引用：直接指向目标的指针或间接定位到目标的句柄。引用的目标一定存在于内存之中。
         类或接口的解析+字段的解析+类方法的解析+接口方法的解析。
    初始化：真正开始执行字节码/java程序。
    
4.类加载器
    定义：实现可以通过一个类的全名来获取描述这个类的字节码的这个动作的一个代码模块称为类加载器。用来实现类的加载动作。
    比较两个类是否相等:同一个类加载器加载的情况下才有意义，即使是存在于同一份字节码中被同一个虚拟机加载，只要类加载器不相同这两个类必然不等。
    这也是判断两个对象是否相等不用instanceOf判断而是获取类加载器来进行判断的原因。这个情况发生在学习equals方法的时候。
    
    
5.双亲委派模型：
    从java开发者角度来划分类加载器：
        启动类加载器:JAVA_HOME\lib目录中,被虚拟机识别的类库加载到虚拟机内存中。
        扩展类加载器:负责加载JAVA_HOME\lib\ext目录中，开发者可直接使用的。
        应用程序类加载器:系统类加载器,负责加载用户类路径ClassPath上指定的类库。
        自定义类加载器:自己定义。
    双亲委派模型:类加载器的层次关系称为双亲委派模型。除却启动类加载器其余加载器必须有自己的父类加载器。他们之间的关系是组合而非继承。
        这也是为什么JAVA编程思想推荐使用组合而不是继承的原因。
    工作过程:类加载器收到类加载请求并不会直接去加载而是委派给父类加载器完成,以此类推直至顶层。如何父类完成不了子类才会去加载。
    好处：JAVA中的类与类加载器一起拥有了层次感。这也就解释了为什么Object是所有对象的父类。这个情况发生在学习JAVASE时解释所有对象的祖先都是Object原因。
