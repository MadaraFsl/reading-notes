1.垃圾回收算法

  1>.Mark-Sweep:标记-清除算法。
     思想:先标记出所有需要回收的对象，标记完成后统一回收这些被标记的对象。
     缺点:1>.标记和清楚的效率都很低。   2>.空间:如同OS中连续分配一样，会产生大量碎片。
     
  2>.Copying:复制算法。适用于新生代的算法。
     目的:为了解决标记清楚算法中的效率问题。
     思想:内存均等划分为两块,使用其一。用完之后，将仍旧存活对象复制另外一块，然后对使用过的内存进行清理。
     优点:半个分区回收,无碎片烦恼,顺序分配内存,简单高效。
     缺点:可用性内存大打折扣折中为一半。
     改进:JAVA堆中的新生代中的对象98%都是快生快死,迭代很快。所以不使用均分方式,而是8:1:1.只浪费10%。
          将Eden和Survivor存活的对象复制到另外一个Survivor空间内。
     缺点:1.在对象存活率高得时候进行较多复制操作,效率降低。2.当这个Survivor空间不够,则需要老年代来进行担保。
  
  3>.Mark-Compact:标记-整理算法。适用于老年代的算法。
     思想:类似于标记-清除算法,但后续不是回收而是将存活的对象移向另外一端,清除的是边界以外的内存。
  
  4>.分代收集算法:商业虚拟机。
     思想:根据对象存活周期的时间将内存分成相应的块。
          新生代:大批对象死亡少数存活,使用复制算法。
          老年代:对象存活率高,无额外空间进行分配担保,使用标记-清除算法或者标记清理算法。
          
2.HotSpot算法实现:

  1>.可以作为GC Root的节点:全局引用和栈帧中的本地变量表。
  
  2>.GC停顿:枚举根结点的时候,可达性分析对时间的要求是确保在一致性的快照中执行,所以GC进行时会停顿所有的JAVA执行线程。
  
  3>.GC停顿后不需要每次检查所有的引用位置,而是通过一个OopMap的数据结构得知存放对象引用的位置。类加载完成时将其记录下来。
  
  
  4>.安全点:特定位置记录信息,这些位置称为安全点。
      作用:并非在所有地方都可以停顿,而是到达安全点才停顿。
      选定标准:大少,GC等待时间过长;太多,增大运行时负荷。所以是程序长时间执行或者指令的重复使用才会产生安全点。
      让所有线程都跑到最近安全点上的方案:
             1>.抢占式中断:GC发生,系统将所有线程中断,判断中断地方是否有不在安全点上则回复线程直到跑至安全点。
             2>.主动式中断:不对线程操作,而是设置标志位,检测标志位的地点于安全点重合,每个线程执行时主动轮询,对比发现为真时就中断挂起.
      缺点:只针对于获得CPU的程序,对于线程处于Sleep与阻塞则无法响应中断要求。
      
  5>安全区:在某个区域的任意地方都是安全的叫做安全区。此时在这段代码中引用关系并不会发生改变。
      作用:解决未获得CPU时间片的程序。
      思想:执行到安全区的代码时,先标记自己已经进入安全区,所以发生GC就不需再去管理已经标识为安全区的状态的线程了。
           当线程离开安全区时先检查GC是否完成,完成则继续运行,未完成需等待直到接收到可以安全离开的信号。
           
     
3.垃圾收集器:内存回收的具体表现。
  CMS收集器:以获取最短的停顿时间为目的的收集器。
      回收步骤:初始标记,并发标记,重新标记,并发清除。
      优点:并发收集,低停顿。
      缺点:1>.对CPU资源很敏感。
           2>.留给下一次GC清理的垃圾无法清除。
           3>.基于标记-清除算法实现的,会产生大量的内存碎片。
           
  G1收集器:
      回收步骤：初始标记,并发标记,最终标记,筛选回收。
      优点: 1>.并发与并行:充分利用CUP和多核环境下的硬件优势。
            2>.分代收集。
            3>.空间整合。因为使用标记-整理算法。
            4>.可以预测的停顿。维护了一个优先列表,在最短时间内回收最大的内存。
            
      CMS与G1比较后G1的优点:整理算法,不会产生内存碎片。
                           精确的控制好停顿的时间。
