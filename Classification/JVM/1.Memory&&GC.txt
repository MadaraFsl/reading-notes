运行时数据区域的划分(抽象的 JVM 的角度)：

  1>.程序计数器:对应OS中的指令计数器来说,保存了下一条需要执行的字节码的指令;
  线程私有内存,不会发生OOM的情况。
  
  2>.JVMStack:java虚拟机栈：方法执行的内存模型,方法执行所需的所有信息在内部开辟栈帧来存储.方法执行的过程队医栈帧在JVM中入栈和出栈的过程。
  线程私有,与线程生命周期相同。
  
  所以就可以解释为什么在JavaWeb的HttpServlet不能像Struts2的Action那样定义一个成员变量去接收页面传递过来的信息.
  HttpServlet是单例且线程不安全的，所以在servlet中接收参数都是在方法内部.如果将参数放在成员变量级别的时候,多个人并发访问会造成线程安全的问题.
  所以HttpServlet则把接受参数放在了方法内部,而在方法内部的时候,方法的生命周期与此时调用的这个线程的生命周期是一致的,并不会发生线程安全问题。
  侧面说明方法的运行是在虚拟机栈,其生命周期与线程相同。
  
  3>.本地方法栈:与java虚拟机栈类似,不过其运行的native方法,而2>运行的是java方法。
  
  4>.java堆:GC堆:存放对象实例, 可以处在物理上不连续,只要逻辑连续的内存空间就可以。
  线程共享的内存区域.Xmx与Xms的设置代表的是其按照可扩展来实现的。
  
  5>.方法区:JVM加载的类信息,产量,静态变量,编译后的代码.同时包括存放各种字面量和符号引用的常量池.
  线程共享的内存区域。
  
  另一种说法是分为：堆（Heap），栈（Stacks），数据段（data segment），代码段（code segment）。是从操作系统上的进程的角度去看的。
  
  具体的可移步知乎查看R大的说法。
  
  GC初步:
    引用计数算法:判断引用计数器的值是否为0来判断对象是否存货,Python中的判断算法就是这种.
    可达性分析算法:GCRoot作为起始点,但一个对象到GCRoot没有任何引用的时候对象则不可用,可回收。
    
    引用分类:
        强引用:new出来的对象,只要强引用存在即不会回收。
        软引用:有用但非必须。电脑里 c 盘满了，这时候我们会清理磁盘，删除对我们来说不是非常重要的东西。
        弱引用:被引用对象只能存活至下一次垃圾回收发生之前.ThreadLocal的中的Entry extends WeakReference<ThreadLocal<?>>。
        虚引用:最弱,目的:垃圾回收后的一个系统通知。
        
6>.什么样的对象会被回收:
    宣告对象死亡:2次可达性算法分析的标记.与finalize方法有关。如果两次标记都没有逃脱,则回收。
    
7>.那些内存需要回收:
    JAVA堆:也称为GC堆,垃圾收集器管理的主要场所。
    因为收集器基本都采用分代收集算法,所以JAVA堆划分:Eden空间,From Survivor,To Survivor. 即:新生代:老年代= 8：1
    方法区:回收内容 废弃常量和无用的类。
        判断常量废弃的条件:无任何引用的常量。
        判断无用的类的条件:
            1.java堆中不存在这个类的任何实例对象。
            2.加载这个类的类加载器ClassLoader已经被回收。
            3.这个类的Class对象没有任何地方被引用,即:永远不可通过反射访问这个类的方法。
    框架中最核心的是:反射+代理。所以需要频繁的自定义ClassLoader的场景需要虚拟机具备卸载的功能。保证不会发生OOM。 
