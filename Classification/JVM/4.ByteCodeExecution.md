### 1.1概述
- 物理机：真实的机器,具有代码执行能力,其执行引擎是建立在处理机、硬件、指令集、和操作系统层面。
- 虚拟机：相对于物理机,和处理机功能一致,只不过执行引擎自己实现,所以可自定义指令集和执行引擎的结构体系,能执行不被硬件直接支持的指令集格式。
- JVM执行引擎过程：输入字节码,然后解析字节码,输出执行结果。

---

### 1.2 运行时栈帧结构。
- 栈帧：虚拟机进行方法调用和方法执行的数据结构。
- 存储了方法的局部变量表,操作数栈,动态链接,方法返回地址等信息,方法的调用执行对应栈帧在虚拟机中的一个入栈出栈过程。
- 栈帧保存的内容：局部变量表+操作数栈+动态链接+方法返回地址

#### 1.2.1 局部变量表
- 是一组变量值的存储空间,存放局部变量。容量是以变量槽位单位计算的。
- 局部变量表中未赋值的变量不会拥有默认值,编译就会出现错误。

#### 1.2.2 操作数栈
- 又称操作栈，也是一个用于存储操作数的数据结构。不过栈中还可以存储各种字节码指令以及调用方法时候的参数传递也是可以通过操作数栈来传递的。

#### 1.2.3 动态链接
- 栈帧包含指向运行时常量池中该栈帧所属方法的引用,为了支持动态链接。
- 静态解析：常量池中的符号引用会在类加载或者第一次直接使用就转化为直接引用。
- 动态解析：另外一部分在运行期间转换为直接引用

#### 1.2.4 方法返回地址
- 正常与非正常的返回相当于栈帧出栈，所以具有的操作包括:回复调用方法的局部变量表和操作数栈,将返回值压入调用者的操作数栈中,调整PC计数器的值。

---
### 1.3 方法的调用。
- 方法调用不等于方法执行,方法调用只是确定要调用的方法是哪一个,不涉及内部的执行过程。

#### 1.3.1 解析
- 类加载阶段的解析:符号引用转化为直接引用。
- 方法调用时的解析：存在已确定的版本在程序调用之前,并且运行期这个版本是不可改变的。方法调用的解析式类加载阶段解析的前提。

#### 1.3.2 分派

```
Public class StaticDispatch {
    static abstract class Human{}
    static class Man extends Human{}
    static class Woman extends Human{}
    
    public void sayHello(Human guy) {
        System.out.println("guy");
    }
    
    public void sayHello(Man man) {
        System.out.println("man");
    }
    
    public void sayHello(Woman man) {
        System.out.println("woman");
    }
    
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);
        sr.sayHello(woman);
    }
}
```
运行结果：</br>
    guy!</br>
    guy!</br>
- 静态类型:Human:静态类型的变化仅仅在使用的时候,变量本身的静态类型是不会变化的,最终静态类型在编译期间是直到的,在次代码中就是Human类型。
- 实际类型:Man：实际类型的变化在运行期才能确定,编译期不可知。
- 所以在这段代码中,因为编译期间发现是Human类型的,所以选择了父类参数的方法作为调用目标。

##### 1.3.2.1 静态分派(重载)
- 静态分配:所有依赖静态类型来定位方法执行的版本的分派动作称为静态分配
- 静态分配的典型:方法的重载。
- 特点:发生于编译期,并且选择的重载版本不唯一,只能确定最合适的。

##### 1.3.2.2 动态分派(重写)
- 动态分派:运行期才可以确定要调用的方法。
- 典型:方法的重写。
- 特点:发生于运行期。

#### 1.3.3 动态类型语言支持
- 静态类型语言:编译期确定类型的语言。
- 动态类型语言:运行期才确定类型的语言。</br>

---

二者优缺点：
- 静态类型语言编译期间确定类型,编译器可以提供严谨的类型检查,利于稳定性和代码达到更大规模。
- 动态类型语言运行期间确定类型,更加灵活,避免了大量臃肿的代码来实现功能,清晰和简洁意味着开发效率的提高。

### 1.4执行方法中的字节码
- 解释执行:边翻译边执行。
- 编译执行:先翻译后执行。

